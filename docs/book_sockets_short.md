# Сетевое программирование от Биджа. Использование интернет	сокетов.
сокращённое изложение  
https://github.com/bakyt92/11_ft_irc/blob/master/docs/bgnet_A4_rus.pdf  

## socket
* socket is an endpoint that enables two processes to communicate with each other, either on the same machine or across a network
* сокет - ключевой компонент для обмена данными между разными системами  
* как Unix-программа выполняет любую операцию ввода/вывода? чтением или записью в дескриптор файла
* дескриптор файла = целое число, связанное с открытым файлом
* файл = реальный файл на дискеь сетевое подключение, FIFO, конвейер, терминал, и всё, что угодно
* `netstat` список открытых сокетов в системе
* установить своё значение таймаута для TCP или UDP сокета
  + 1 вариант: setsockopt() с SO_RCVTIMEO и SO_SNDTIMEO, но не все системы поддерживают
  + 2 вариант: использовать `alarm()` или `setitimer()`

### stream socket
* internet-socket
* подключаемый двунаправленный поток связи
* используется в telnet приложениях
* для загрузки страниц web браузерами по HTTP протоколу
  + если подключиться к web сайту по telnet-у и, напечатать “GET / HTTP/1.0”, получишь html
* The Transmission Control Protocol (TCP) обеспечивает появление данных последовательно и без ошибок

### datagram socket (нам не нужно)
* internet-socket
* “неподключаемый” (без установки логического соединения)
  + не открываете точку подключения, как при потоковых сокетах
  + строите пакет, прикрепляете к нему IP заголовок с адресом назначения и отсылаете
  + подключения не требуются
  + но можно подключиться connect()-ом при желании
* если отправите в сокет послания “1, 2”, то на другой стороне они появятся в порядке “1, 2” (перепроверить)
* ненадёжны
  + если посылаете дейтаграмму, она может и появиться
  + она может появиться не в нужном порядке
  + если появилась, то данные в пакете будут переданы без ошибок
* хорошая скорость
* используют IP маршрутизацию
* используют User Datagram Protocol, UDP (не TCP)
* нужны, когда недоступен TCP стек или когда допускаeтся потеря нескольких пакетов (игры, звук, видео)

## IP	адрес, порт
* система маршрутизации сетей Internet Protocol Version 4, IPv4
  + адреса из четырёх байт (192.0.02.111)
  + все сайты используют IPv4
* IPv6
  + `192.0.2.33` = `::ffff:192.0.2.33`
* подсеть
  + первая часть IP является сетевой частью IP адреса, а остальная это часть хоста
* порт ≈ местный адрес для соединений
  + чтобы компьютер обрабатывал входящую почту и web сервисы, т.е. различить их на компьютере с одним IP адресом
  + IP ≈ адрес отеля, номер порта ≈ номер комнаты
  + различные интернет сервисы имеют различные известные номера портов (HTTP 80, telnet 23, SMTP 25, ...)
* определить доступные порты
  + если пишете web сервер, используйте порт 80
  + если пишете свой специализированный сервер, попробуйте случайный порт (больше 1023), если то bind()  “Address already in use”, попробуйте другой порт
  + можно позволить пользователю самому определить альтернативный порт (в config файле либо ключом в командной строке)
  + Internet Assigned Numbers Authority (IANA) определяет список официальных номеров портов
    - если какой-либо порт (старше 1023) находится в этом списке, вы всё равно можете его использовать
    - важно лишь, чтобы в это время никто кроме вас не использовал этот порт на этой же машине
    - например, DOOM от Id Software использует такой порт как “mdqs”, каким бы он ни был (???)
* порядок	байт	
  + Big-Endian / Little-Endian
  + Network Byte Order (=Big-Endian) / Host Byte Order
  + строя пакет или заполняя структуры вам нужно быть уверенным, что числа построены в Порядке Байтов Сети
    - прогоняете данные через **функции (системные вызовы) установки порядка байт сети** (`htons()`, `htonl()`, `ntohs()`, `ntohl()`)
    - преобразовать числа в Порядок Байтов Сети перед тем, как послать
    - в Порядок Байтов Хоста, когда они оттуда придут
    - если вам захочется поработать с плавающей запятой, см. Сериализация
* IPv6 имеет адрес и номер порта также, как IPv4
* параграф "4. Прыжок из IPv4 в IPv6" нам не нужен, там описывают, как менять код, предназначенный для IPv4, чтобы они работал с IPv6

## системные вызовы и функции
* работу системного вызова выполняет ядро
* тут в примерах не включена проверка на ошибки
* я добавила в этот раздел функции, которые есть в задании (но нет в книге): setsockopt(), getsockname(), getprotobyname(), gethostbyname(), freeaddrinfo(), signal(), sigaction(), lseek(), fstat(), fcntl(), poll() or equivalent
* я не включила в этот раздел функции, которых нет в задании (но есть в книге): sendto(), recvfrom(), shutdown(), getpeername(), gethostname()

### getaddrinfo()
* поиск имён DNS и служб
* заполняет структуры
* параметры
  + node: имя или IP адрес хоста
  + service: номер порта или имя службы, например `http`, `ftp`, `telnet`, `smtp` (см. `/etc/services`)
  + hints: указывает на struct addrinfo, которую вы уже заполнили нужной информацией
* возвращает указатель на связанный список результатов
  
Пример: заполнения структур для сервера, который будет слушать порт 3490 вашего IP адреса
```
int             status;
struct addrinfo hints;
struct addrinfo *servinfo;                                          // укажет на результат

memset(&hints, 0, sizeof hints);
hints.ai_family   = AF_UNSPEC;                                      // мне всё равно IPv4 либо IPv6
hints.ai_socktype = SOCK_STREAM;                                    // потоковый сокет TCP
hints.ai_flags    = AI_PASSIVE;                                     // назначить структурам сокета адрес моего локального хостазаписать мой IP для меня
if ((status = getaddrinfo(NULL, "3490", &hints, &servinfo)) != 0) { // servinfo указывает на связанный список из 1 или более struct addrinfo
  fprintf(stderr, "getaddrinfo error: %s\n", gai_strerror(status));
  exit(1);
}
freeaddrinfo(servinfo);                                             // освободить связанный список
```  
Пример: заполнение структур клиента для соединия с сервером “www.example.net”, порт 3490
```
struct addrinfo hints;
struct addrinfo *servinfo;                                             // укажет на результат

memset(&hints, 0, sizeof hints);
hints.ai_family   = AF_UNSPEC;
hints.ai_socktype = SOCK_STREAM;
int status = getaddrinfo("www.example.net", "3490", &hints, &servinfo); // готовьтесь к соединению
// servinfo указывает на связанный список из 1 или более struct addrinfo
```
Пример: программа выводит IP адрес заданного в командной строке хоста (1 аргумент)
```
int main(int argc, char *argv[]) {
  struct addrinfo hints, *res, *p;
  int             status;
  char            ipstr[INET6_ADDRSTRLEN];

  memset(&hints, 0, sizeof hints);
  hints.ai_family    = AF_UNSPEC;
  hints.ai_socktype = SOCK_STREAM;
  if ((status = getaddrinfo(argv[1], NULL, &hints, &res)) != 0) 
    return (fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(status)), 2);
  printf("IP addresses for %s:\n\n", argv[1]);
  for(p = res;p != NULL; p = p->ai_next) {
    void *addr;
    char *ipver;
    if (p->ai_family == AF_INET) { // в IPv4 и IPv6 поля разные
      struct sockaddr_in *ipv4 = (struct sockaddr_in *)p->ai_addr;
      addr = &(ipv4->sin_addr);
      ipver = "IPv4";
    } else {
      struct sockaddr_in6 *ipv6 = (struct sockaddr_in6 *)p->ai_addr;
      addr = &(ipv6->sin6_addr);
      ipver = "IPv6";
    }
    inet_ntop(p->ai_family, addr, ipstr, sizeof ipstr); // перевести IP в строку и распечатать
    printf(" %s: %s\n", ipver, ipstr);
  }
  freeaddrinfo(res);
  return 0;
}
```
### socket() получить дескриптор файла
* параметры
  + IPv4 или IPv6 (`PF_INET` или `PF_INET6`) (`AF_INET` почти то же, что `PF_INET`)
  + потоковый или дейтаграммный (`SOCK_STREAM` или `SOCK_DGRAM`)
  + TCP или UDP (0 или вызвать getprotobyname() и выбрать нужный протокол, `tcp` or `udp`)
* возвращает дескриптор сокета, который вы можете позже использовать в системных вызовах

Пример: взять данные из результатов вызова getaddrinfo() и передать их socket()
```
struct addrinfo hints, *res;                                              // полагаем, что “hints" уже заполнена

getaddrinfo("www.example.com", "http", &hints, &res);                     // проверить выход getaddrinfo() на ошибки
int sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);  // просмотреть список res на действительный элемент, не полагаясь на то, что это первый
```
### bind() На каком я порте?
* чтобы слушать (`listen()`) входные подключения, сервер связывает сокет с портом на вашей локальной машине
* для клиента это не нужно
* параметры:
  + файловый дескриптор сокета, возвращенный socket()-ом
  + указатель на struct sockaddr, которая содержит информацию о вашем адресе, а именно, порт и IP address
  + длина этого адреса в байтах
* бывают времена, когда вы абсолютно не можете вызвать bind(). Если вы подключаетесь (connect()) к уделённой машине и вас не заботит номер локального порта (как в случае с telnet, где вам нужен только удалённый порт), вы можете просто вызвать connect(), он проверит, подключён ли порт и, если необходимо, вызовет bind() и подключит свободный локальный порт (???)
* номер порта от 1024 до 65535
* Если кусочек подключавшегося сокета висит в ядре и занимает порт и перезапускаете сервер, то bind() говорит “Адрес уже занят”. Одно из двух рещшений:
  + подождать около минуты, пока он очистится
  + добавить код, позволяющий использовать порт повторно:
```
int yes=1;
if (setsockopt(listener,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof(int)) == -1) {
  perror("setsockopt");
  exit(1);
}
```
Пример: привяжем сокет к порту 3490 хоста
```
struct addrinfo hints, *res;

// заполнить адресные структуры с помощью getaddrinfo():
memset(&hints, 0, sizeof hints);
hints.ai_family   = AF_UNSPEC;
hints.ai_socktype = SOCK_STREAM;
hints.ai_flags    = AI_PASSIVE;                                          // привязаться к IP хоста, на котором выполняется
getaddrinfo(NULL, "3490", &hints, &res);                                 // если хотите соединиться с отдельным локальным IP адресом, укажите IP адрес в первом аргументе getaddrinfo()
int sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol); // создать сокет
bind(sockfd, res->ai_addr, res->ai_addrlen);                             // связать с портом, полученным из getaddrinfo()
```
Пример: Заполняем sockaddr_in вручную. Это специфично для IPv4, дляIPv6 тоже можно так делать. В книжке помечен как устаревший, но в нашем задании есть эти функции.  
```
struct sockaddr_in my_addr;

int sockfd              = socket(PF_INET, SOCK_STREAM, 0);
my_addr.sin_family      = AF_INET;
my_addr.sin_port        = htons(MYPORT);                     // порядок байт сети
my_addr.sin_addr.s_addr = inet_addr("10.12.110.57");         // можно INADDR_ANY
memset(my_addr.sin_zero, '\0', sizeof my_addr.sin_zero);
bind(sockfd, (struct sockaddr *)&my_addr, sizeof my_addr);
```
### connect()
* подключиться к “10.12.110.57” на порт 23
* параметры (всё это можно получить из `getaddrinfo()`):
  + файловый дескриптор сокета соседа, возвращённый вызовом socket()
  + struct sockaddr, содержащая порт и IP адрес назначения
  + длина этой структуры в байтах
* не вызываем `bind()`, нас заботит только удалённый порт, ядро подберёт локальный порт и подключённый сайт будет получать от нас информацию
* программы старой школы заполнены своими собственными struct sockaddr_in для передачи в `connect()`, см. раздел bind()
* Как изменить или сократить таймаут вызова connect() ? (???)
  + см. W. Richard Stevens
  + см. lib/connect_nonb.c [в UNIX Network Programming source code](http://www.unpbook.com/src.html)
  + создаёте дескрипор сокета вызовом socket()
  + делаете его неблокируемым
  + вызываете connect()
  + если всё хорошо, connect() возвратит -1 и установит errno в EINPROGRESS
  + вызваете select() с нужным таймаутом, передавая дескриптор в обоих массивах, чтения и записи
  + если таймаут не сработал, значит вызов connect() завершён
    - нужно использовать getsockopt() с опцией SO_ERROR чтобы получить возврат из функции connect(), который должен быть нулевым, если не было ошибки
  + если нужно до начала передачи данных через сокет опять сделать его блокируемым
  + при этом что в вашу программу была добавлена возможность делать что-либо ещё, пока она подключается, например:
    - установить таймаут маленьким, вроде 500 ms
    - обновлять индикатор на экране каждый таймаут и вызывать select() снова
    - когда таймаут вызовов истечёт, скажем, 20 раз, вы будете знать, что пора отказаться от соединения

Пример: подключим сокет к “www.example.com”, порт 3490
```
struct addrinfo hints, *res;

memset(&hints, 0, sizeof hints);    
hints.ai_family   = AF_UNSPEC;
hints.ai_socktype = SOCK_STREAM;
getaddrinfo("www.example.com", "3490", &hints, &res); // заполняем адресные структуры
int sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol); // создать сокет
connect(sockfd, res->ai_addr, res->ai_addrlen);
```
### listen()
* Если не хотите подключаться к удалённому хосту, а дождаться входящих подключений и затем их как-то обрабатывать:
  + listen()
  + accept()
* параметры
  + файловый дескриптор сокета из socket()
  + число разрешённых входных подключений во входной очереди, входящие подключения будут ждать в очереди пока вы их не примете (accept()), и это предел, сколько их там может быть
* вызвать bind() до listen(), так что сервер работает на определенном порте (вы должны знать, как сказать вашим приятелям, к какому порту подключаться!), если собираетесь слушать входящие подключения, то:
```
getaddrinfo();
socket();
bind();
listen();
/* accept() будет тут */
```
### accept()
* параметры:
  + дескриптор слушающего сокета
  + указатель на локальную структуру sockaddr_storage, сюда приходит информация о входящих подключениях (можете определить какой хост вызывает вас и с какого порта)
  + размер struct sockaddr_storage до того как её адрес передан accept()
    - локальная целая переменная
    - accept() не запишет в addr больше, чем указано, байт
    - если запишет меньше указанного байт, то изменит значение addrlen
* когда кто-то пытается подключиться вызовом connect() к вашей машине на порт, который вы слушаете вызовом listen():
  + это соединение будет поставлено в очередь ждать accept()-а
  + вы вызываете accept() и говорите ему принять ожидающие подключения
  + accept() вернёт новый файловый дескриптор сокета для использования с одним подключением
  + у вас появилось два файловых дескриптора сокета: исходный слушает новые подключения, а вновь созданный готов к send() и recv()
Пример
```
#define MYPORT "3490"                                                     // номер моего порта для подключения пользователей
#define BACKLOG 10                                                        // размер очереди ожидающих подключений
int main(void) {
  struct sockaddr_storage their_addr;
  struct addrinfo         hints, *res;

  memset(&hints, 0, sizeof hints);
  hints.ai_family   = AF_UNSPEC;
  hints.ai_socktype = SOCK_STREAM;
  hints.ai_flags    = AI_PASSIVE;                                          // заполнить мой IP для меня
  getaddrinfo(NULL, MYPORT, &hints, &res);                                 // заполнить адресные структуры
  int sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol); // создать сокет
  bind(sockfd, res->ai_addr, res->ai_addrlen);
  listen(sockfd, BACKLOG);
  socklen_t addr_size = sizeof their_addr;
  int new_fd = accept(sockfd, (struct sockaddr *)&their_addr, &addr_size); // принять входящие подключения
  // связываемся по дескриптору сокета new_fd
}
```

### send()
* ≈ `write()`, но больше возможностей управления передачей данных
* `send()` и `recv()` обеспечивает связь по сокетам
* параметры 
  + дескриптор сокета, куда вы хотите отправить данные, возможно он был возвращён sозвращён socket() или получен accept()
  + указатель на посылаемые данные
  + длина этих данных в байтах
  + flags просто установите в 0
* `send()` возвращает количество действительно посланных байтов, это число не совпадает с len, то надо послать остаток строки
* кодировать или сжимать данные перед посылкой через сокет (кажется нам не нужно):
  + использовать SSL (secure sockets layer), но это выходит за рамки этого руководства
  + если хотите внедрить вашу собственную систему сжатия или кодирования данных:
    1. клиент принимает кодированные данные (recv() )
    2. клиент декодирует/разворачивает данные (это добавляете вы)
    3. клиент пишет данные в файл(или ещё куда-то)
    4. сервер читает данные из файла (или ещё откуда-то)
    5. сервер кодирует/сжимает данные (это добавляете вы)
    6. сервер посылает кодированные данные (send())
  + если вы собираетесь и сжимать и кодировать, то сначала сжимать
* если запуститься на локальной машине, то большое кличество данных принимаются за один раз
  + на локальной машине вы используете loopback устройство, которое может обрабатывать 8K или больше
* если через сервир и клиент сеодинены через сеть, то за раз приходит только 536 или 1460 байт
  + MTU - максимальный размер пакета, который может обработать физическая среда
  + Ethernet может обрабатывать только 1500 байт с заголовком
  + модем c 576 MTU может обрабатывать только 1500 байт с заголовком
  + см. раздел книги Дитя Инкапсуляции Данных, как принимать целые пакеты данных многократным вызовом recv()
* вы хотите послать 512 байт, send() возвращает 412, что случилось с оставшимися 100 байтами?
  + ядро решило не посылать их одним куском
  + 100 байт до сих пор в вашем буфере ждут отсылки
  + надо взять их оттуда, например так:
```
int sendall(int s, char *buf, int *len) { // s = сокет, куда хотите послать, len количество байт в буфере
  int total = 0;                                        // сколько байт послали
  int bytesleft = *len;                                 // сколько байт осталось послать
  int n;

  while(total < *len) {
    n = send(s, buf+total, bytesleft, 0);
    if (n == -1)
      break; 
    total += n;
    bytesleft -= n;
  }
  *len = total; // количество действительно посланных байт
  return n==-1?-1:0; // вернуть -1 при сбое (errno установлена send()), 0 при успехе
}
```

Пример:
```
char *msg = "Beej was here!";

int len = strlen(msg);
int bytes_sent = send(sockfd, msg, len, 0);
```
### recv()
* ≈ `read()`, но больше возможностей управления передачей данных
* `send()` и `recv()` обеспечивает связь по сокетам
* параметры:
  + дескриптор сокета для чтения
  + буфер куда читать
  + максимальная длина буфера
  + flags установить в 0
* возвращает действительное количество записанных в буфер байтов
* если вернул 0, означает, удалённая сторона закрыла подключение
* можно применять таймаут, см. пример в книге на стр. 61 (с испольщованием select())

### close()	
* предотвратит дальнейшее чтение и запись в сокет
* освобождает дескриптор
   
### setsockopt()
### getsockname()
### getprotobyname()
### gethostbyname()
### freeaddrinfo()
### signal()
### sigaction()
### lseek()
### fstat()
### fcntl()
### poll() 
* вместо него можно использовать `select()`, `kqueue()` или `epoll()`
### select()
* select() не ладит с сигналами
  + cигналы принуждают заблокированные системные вызовы возвращать -1, устанавливая errno в EINTR
  + когда вы устанавливаете обработчик сигналов функцией sigaction():
    - можете установить флаг SA_RESTART, который предполагает перезапуск системного вызова после того, как он был прерван
    - это не всегда работает
    - решение: привлекать `goto` (см. пример в книге на стр. 60) или использовать другие структуры вместо goto
### kqueue()
### epoll()

## типы данных, применяемых в интерфейсе сокетов
### 1. дескриптор сокета: `int`
### 2. addrinfo
  + для подготовки адресных структур сокета для дальнейшего использования
  + для поиска имён хоста и службы
  + это одна из первых вещей, вызываемых при создании соединения
  + `getaddrinfo()` возвращает указатель на новый связанный список этих структур
  + обычно нет нужды заполнять эти структуры, достаточно вызвать `getaddrinfo()`, всё нужное там
  + код, написанный до изобретения структуры addrinfo, вставлял все эти принадлежности вручную
```
struct addrinfo {
  int                ai_flags;          // AI_PASSIVE, AI_CANONNAME, т.д.
  int                ai_family;         // AF_INET, AF_INET6, AF_UNSPEC
  int                ai_socktype;       // SOCK_STREAM, SOCK_DGRAM
  int                ai_protocol;       // используйте 0 для"any"
  size_t             ai_addrlen;        // размер ai_addr в байтах
  struct sockaddr    *ai_addr;          // struct sockaddr_in или _in6
  char               *ai_canonname;     // полное каноническое имя хоста
  struct addrinfo    *ai_next;          // связанный список, следующий
};
```
### 3. sockaddr
  + содержит адресную информацию для многих типов сокетов
  ```
  struct sockaddr {
    unsigned         short sa_family;   // семейство адресов, у нас AF_INET (IPv4) или AF_INET6
    char             sa_data[14];       // адрес назначения и номер порта для сокета
  };
  ```
### 4. sockaddr_in
  + для работы со структурой sockaddr
  + только для IPv4
  + “in” = “Internet”
  + указатель на sockaddr_in может быть приведен к указателю на sockaddr, и наоборот## инкапсуляция данных (кажется нам не нужно)
![Screenshot from 2024-04-06 17-00-28](https://github.com/akostrik/IRC-fork/assets/22834202/2697a7e0-024c-48ff-a907-42b82bd057a1)
1. пакет рождён
2. пакет завёрнут (инкапсулирован) в заголовок (реже и хвостик) протоколом первого уровня (скажем, TFTP)
3. вся штучка (включая TFTP заголовок) инкапсулируется следующим протоколом (скажем, UDP)
4. снова следующим (IP)
5. снова протоколом аппаратного (физического) уровня (скажем, Ethernet)

Layered Network Model (aka “ISO/OSI”), 7 уровней:
1. Приложений (telnet, ftp, ...)
2. Представления
3. Сессии
4. Транспортный (TCP, UDP)
5. Сетевой (IP и маршрутизация)
6. Данных
7. Физический (уровень доступа к сети, Ethernet, wi-fi, ...)

  + `connect()` требует `struct sockaddr*`, вы можете пользоваться структурой `sockaddr_in`
  + позволяет обращаться к элементам адреса сокета
  + `sin_zero` включён для расширения длины структуры до длины sockaddr
  + `sin_zero` должен быть обнулён функцией `memset()`
  + `sin_family` соответствует `sockaddr.sa_family` и должен быть установлен в `AF_INET`
  + используйте htons()
```
struct sockaddr_in {
  short int          sin_family;        // семейство адресов, AF_INET
  unsigned short int sin_port;          // номер порта
  struct in_addr     sin_addr;          // интернет адрес
  unsigned char      sin_zero[8];       // размер как у struct sockaddr
};
```
### 5. in_addr
  + исторически обоснованная структура
  + только для IPv4
  + интернет адрес
  + даже если ваша система до сих пор использует `union` для структуры `in_addr`, вы всё равно можете ссылаться на 4-байтный IP адрес благодаря #define-ам
```
struct in_addr {
  uint32_t           s_addr;            // 32-битный int
};
```
Пример 
```
struct sockaddr_in ina;
ina.sin_addr.s_addr;                    // 4-байтный IP адрес (в Порядке Байтов Сети) 
```
### 6. sockaddr_in6
  + только для IPv6
```
struct sockaddr_in6 {                  
  u_int16_t       sin6_family;          // семейство адресов, AF_INET6
  u_int16_t       sin6_port;            // номер порта, Порядок Байтов Сети
  u_int32_t       sin6_flowinfo;        // потоковая информация IPv6
  struct in6_addr sin6_addr;            // (???) адрес IPv6, можно записать глобальную переменную in6addr_any, можно использовать макрос IN6ADDR_ANY_INIT (≈ INADDR_AN` для IPv4) 
  u_int32_t       sin6_scope_id;        // Scope ID
};
```
### 7. in6_addr
  + только для IPv6
```
struct in6_addr {
  unsigned char  s6_addr[16];            // адрес IPv6
}
```
### 8. sockaddr_storage **(?)**
  + содержит обе IPv4 и IPv6 структуры
  + подобна `sockaddr`, только больше
  + если не знаете наперёд, каким адресом загружать структуру `sockaddr` (IPv4 или IPv6), то передайте sockaddr_storage и приведите к нужному типу
  + через `ss_family`посмотреть - это `AF_INET или AF_INET6, и, когда нужно, привести к `sockaddr_in` или `sockaddr_in6`
```
struct sockaddr_storage{
  sa_family_t    ss_family;              // семейство адресов
  char           __ss_pad1[SS_PAD1SIZE]; // выравнивание длины, зависит от реализации, проигнорируйте
  int64_t        __ss_align;
  char           __ss_pad2[SS_PAD2SIZE];
};
```

### преобразования формы записи IP-адреса
+ упаковывать IP-адрес в long оператором `<<` нет нужды
+ `inet_pton()` 
  - pton = presentation to network
  - преобразовывать строковые IP адреса в их двоичное представление
  - преобразует `10.12.110.57` или `2001:db8:63b3:1::3490` в `struct in_addr` либо `struct in6_addr` в зависимости от параметра AF_INET или AF_INET6
  - возвращает -1 при ошибке и 0 если произошла какая-то путаница (надо проверять)
  - нет в задании
+ `inet_ntop()`
  - nton = network to presentation
  - например, чтобы напечатать `struct in_addr`в представлении `10.12.110.57`
  - например, чтобы напечатать `struct in6_addr`в представлении `2001:db8:63b3:1::3490`
  - нет в задании
+ эти функции работают только с цифровыми IP адресами, не с именами хостов для DNS серверов типа `www.example.com` (для `www.example.com` использовать `getaddrinfo()`)
+ `inet_addr()` (устаревшая, не работает с IPv6, но указана в нашем задании)
+ `inet_aton()` (устаревшая, не работает с IPv6, но указана в нашем задании)
+ `inet_ntoa()` (устаревшая, не работает с IPv6, но указана в нашем задании)
+ `htons()`
+ `htonl()`
+ `ntohs()`
+ `ntohl()`

`10.12.110.57` -> `struct sockaddr_in`  
```
struct sockaddr_in  sa;        
inet_pton(AF_INET, “192.0.2.1”, &(sa.sin_addr));   
```
`2001:db8:63b3:1::3490` -> `struct sockaddr_in6`
```
struct sockaddr_in6 sa6;   
inet_pton(AF_INET6, “2001:db8:63b3:1::3490”, &(sa6.sin6_addr));
```
`struct sockaddr_in` -> `10.12.110.57`
```
charIPv4            ip4[INET_ADDRSTRLEN];                    // место для строки IPv4
struct sockaddr_in  sa;                                      // предположительно чем-то загружено
inet_ntop(AF_INET, &(sa.sin_addr), ip4, INET_ADDRSTRLEN);
printf(“The IPv4 address is: %s\n”, ip4);
```
`struct sockaddr_in6` -> `2001:db8:63b3:1::3490`
```
charIPv6            ip6[INET6_ADDRSTRLEN];                   // место для строки IPv6
struct sockaddr_in6 sa6;                                     // предположительно чем-то загружено
inet_ntop(AF_INET6,&(sa6.sin6_addr), ip6, INET6_ADDRSTRLEN);
printf(“The IPv6 address is: %s\n”, ip6);
```
## Архитектура Клиент­‐Сервер 	
* пара клиент-сервер могут говорить на SOCK_STREAM, SOCK_DGRAM или чём угодно, если они говорят на одном языке
* например:
  + telnet/telnetd
  + ftp/ftpd (когда вы используете ftp, есть удалённая программа ftpd, которая обслуживает вас)
  + Firefox/Apache
* Как запустить клиент и сервер если у меня только один компьютер?
  + Cеть для написания сетевых программ не нужна.
  + Все машины имеют закольцованное (loopback) сетевое “устройство”, которое сидит в ядре и претендует на звание сетевой карты (это интерфейс “lo” в таблице маршрутизации).
  + Вносить изменения в программу, чтобы она работала на отдельной, не подключённой к сети машине, не нужно.
  + Два варианта:
    - запустите клиент в одном окне и сервер в другом
    - запустите сервер в фоновом режиме (“server &”) и клиент в том же окне
  + с loopback-устройством вы можете задавать `client login_name` или `client localhost` (???)
* часто один сервер обслуживает множество клиентов:
  + сервер ждёт подключения
  + принимает его (`accept()`)
  + запускает процесс-потомок для его обслуживания (`fork()`)
* серверу может принять от клиента команды и выполниь их:
  + вариант, когда клиент подключается, посылает данные и закрывает соединение, для последующих вызовов
клиент подключается вновь
  + клиент:
    - подключается к серверу (connect())
    - посылает (send(“/sbin/ls > /tmp/client.out”))
    - закрывает соединение (close())
  + сервер:
    - принимает соединение от клиента (accept())
    - получает командную строку (recv(str))
    - закрывает соединение (close())
    - запускает команду (system(str))
  + позволить серверу выполнять команды клиента с помощью `system()` небеопасно:
    - если клиент пришлёт `rm -rf ~`, это удалит всё
    - если сервер разрешает клиенту прислать команду с безопасной утилитой `foobar` и клиент пришлёт `foobar; rm -rf ~`, то тоже проблема
    - решение: вставлять `\` перед всеми не алфавитно-цифровыми символами (включая пробелы) в аргументах команды

Пример сервера потокового сокета:
```
#define PORT "3490"  // порт для подключения пользователей
#define BACKLOG 10   // размер очереди ожидающих подключений

void sigchld_handler(int s) {
  while(waitpid(-1, NULL, WNOHANG) > 0);
}

void *get_in_addr(struct sockaddr *sa) { // получить sockaddr, IPv4 или IPv6
  if (sa->sa_family == AF_INET)
    return &(((struct sockaddr_in*)sa)->sin_addr);
  return &(((struct sockaddr_in6*)sa)->sin6_addr);
}

int main(void) {
  int                     sockfd, new_fd, rv, yes=1;                // слушать на sock_fd, новое подключение на new_fd
  struct addrinfo         hints, *servinfo, *p;
  struct sockaddr_storage their_addr;                                // адресная информация подключившегося
  socklen_t               sin_size;
  struct sigaction        sa;
  char                    s[INET6_ADDRSTRLEN];

  memset(&hints, 0, sizeof hints);
  hints.ai_family   = AF_UNSPEC;
  hints.ai_socktype = SOCK_STREAM;
  hints.ai_flags    = AI_PASSIVE;                                    // использовать мой IP
  if ((rv = getaddrinfo(NULL, PORT, &hints, &servinfo)) != 0)
    return (fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv)), 1);
  for(p = servinfo; p != NULL; p = p->ai_next) {                     // цикл по всем результатам и связывание с первым возможным
    if ((sockfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) == -1) {
      perror("server: socket");
      continue;
    }
    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1) {
      perror("setsockopt");
      exit(1);
    }
    if (bind(sockfd, p->ai_addr, p->ai_addrlen) == -1) {
      close(sockfd);
      perror("server: bind");
      continue;
    }
    break;
  }
  if (p == NULL)
    return (fprintf(stderr, "server: failed to bind\n"), 2);
  freeaddrinfo(servinfo);
  if (listen(sockfd, BACKLOG) == -1) {
    perror("listen");
    exit(1);
  }
  sa.sa_handler = sigchld_handler;                              // удалить мёртвые процессы
  sigemptyset(&sa.sa_mask);
  sa.sa_flags = SA_RESTART;
  if (sigaction(SIGCHLD, &sa, NULL) == -1) {                    // уборка зомби, которые появляются при завершении
потомка после fork()
    perror("sigaction");
    exit(1);
  }
  printf("server: waiting for connections…\n");
  while(1) {                                                    // главный цикл accept()
  sin_size = sizeof their_addr;
  new_fd = accept(sockfd, (struct sockaddr *)&their_addr, &sin_size);
  if (new_fd == -1) {
    perror("accept");
    continue;
  }
  inet_ntop(their_addr.ss_family,
  get_in_addr((struct sockaddr *)&their_addr), s, sizeof s);
  printf("server: got connection from %s\n", s);
  if (!fork()) {                                               // порождённый процесс
    close(sockfd);                                             // его слушать не нужно
    if (send(new_fd, "Hello, world!", 13, 0) == -1)
      perror("send");
    close(new_fd);
    exit(0);
    }
  }
  close(new_fd);                                               // родителю это не нужно
  return 0;
}
```
Пример клиента потокового сокета:
```
#define PORT "3490"                                            // порт для подключения клиентов
#define MAXDATASIZE 100                                        // максимальная длина принимаемых за раз данных
void *get_in_addr(struct sockaddr *sa) {                       // получить sockaddr, IPv4 или IPv6
  if (sa->sa_family == AF_INET) 
    return &(((struct sockaddr_in*)sa)->sin_addr);
  return &(((struct sockaddr_in6*)sa)->sin6_addr);
}

int main(int argc, char *argv[]) {
  int             sockfd, numbytes, rv;
  char            buf[MAXDATASIZE];
  struct addrinfo hints, *servinfo, *p;
  char            s[INET6_ADDRSTRLEN];

  if (argc != 2) {
    fprintf(stderr,"usage: client hostname\n");
    exit(1);
    }
  memset(&hints, 0, sizeof hints);
  hints.ai_family   = AF_UNSPEC;
  hints.ai_socktype = SOCK_STREAM;
  if ((rv = getaddrinfo(argv[1], PORT, &hints, &servinfo)) != 0) 
    return (fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv)), 1);
  for(p = servinfo; p != NULL; p = p->ai_next) {                        // цикл по всем результатам и связывание с первым возможным
    if ((sockfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) == -1) {
      perror("client: socket");
      continue;
    }
    if (connect(sockfd, p->ai_addr, p->ai_addrlen) == -1) {
      close(sockfd);
      perror("client: connect");
      continue;
    }
    break;
  }
  if (p == NULL)
    return (fprintf(stderr, "client: failed to connect\n"), 2);
  inet_ntop(p->ai_family, get_in_addr((struct sockaddr *)p->ai_addr), s, sizeof s);
  printf("client: connecting to %s\n", s);
  freeaddrinfo(servinfo);
  if ((numbytes = recv(sockfd, buf, MAXDATASIZE-1, 0)) == -1) {
    perror("recv");
    exit(1);
  }
  buf[numbytes] = ’\0’;
  printf("client: received ’%s’\n",buf);
  close(sockfd);
  return 0;
}
```

## инкапсуляция данных (кажется нам не нужно)
![Screenshot from 2024-04-06 17-00-28](https://github.com/akostrik/IRC-fork/assets/22834202/2697a7e0-024c-48ff-a907-42b82bd057a1)
1. пакет рождён
2. пакет завёрнут (инкапсулирован) в заголовок (реже и хвостик) протоколом первого уровня (скажем, TFTP)
3. вся штучка (включая TFTP заголовок) инкапсулируется следующим протоколом (скажем, UDP)
4. снова следующим (IP)
5. снова протоколом аппаратного (физического) уровня (скажем, Ethernet)

Layered Network Model (aka “ISO/OSI”), 7 уровней:
1. Приложений (telnet, ftp, ...)
2. Представления
3. Сессии
4. Транспортный (TCP, UDP)
5. Сетевой (IP и маршрутизация)
6. Данных
7. Физический (уровень доступа к сети, Ethernet, wi-fi, ...)

## частные (= отключённые) сети	(кажется нам не нужно)
* брандмауэр скрывает сеть от остального мира
* брандмауэр транслирует “внутренние” IP адреса во “внешние” (известные всему миру) IP адреса с помощью процесса Network Address Translation (NAT)
* начинающему не нужно беспокоиться об NAT
* Например:
  + есть брандмауэр, два статичных IPv4 адреса, выделенных мне DSL компанией, и 7 компьютеров в сети
  + два компьютера не могут иметь одинаковый адрес
  + они находятся в частной сети с выделенными для неё 24 миллионами IP адресов
  + если я вхожу в удалённый компьютер - он говорит мне, что я вошёл с `192.0.2.33`, публичного IP, который мне выделил мой провайдер
  + если я спрашиваю у моего локального компьютера его адрес, он отвечает `10.0.0.5`
  + брандмауэр + NAT транслируют один IP адрес в другой
* номера частных сетей: наиболее частые `10.x.x.x` и `192.168.x.x`, менее распространены `172.y.x.x`, y от 16 до 31
* адреса `10.x.x.x` зарезервированны, используются в полностью отключённых сетях либо за брандмауэрами
  + сетям за брандмауэром не нужно быть одной из этих зарезервированных сетей, но обычно это так
* IPv6 тоже имеет частные сети
  + начинаются с `fdxx:`
  + NAT и IPv6 как правило не смешиваются, однако у вас будет столько адресов, что NAT больше не
понадобится
  + можно выделить для себя адреса в сети, которая не доступна снаружи
* Я под брандмауэром - как указать людям за ним мой IP адрес, чтобы они подключились к моей машине?
  + цель брандмауэра - предотвратить подключение людей за брандмауэром к машинам под ним
  + разрешение такого подключения рассматривается как брешь в безопасности
  + брандмауэр использует маскарадинг, NAT, ...:
  + обойти можно так: напишите программу так, чтобы инициатором соединения всегда были вы
  + или так: попросите системного администратора проткнуть дыру в брандмауэре, чтобы люди могли к вам подключаться
    - брандмауэр может пробираться к вам либо через свои NAT программы, либо через прокси, либо через нечто подобное
    - вы должны быть уверены, что не даёте злоумашенникам доступа во внутреннюю сеть
    - сделать программы безопасными труднее, чем кажется

## прочее
* Блокировка
  + ≈ сон
  + recvfrom(), accept(), recv() блокируются, пока не появятся данные
  + этим системным вызовам разрешено блокироваться
  + когда создаёте сокет функцией socket(), ядро устанавливает его на блокировку (???)
  + если не хотите, чтобы сокет блокировался:
    - выполните `fcntl(sockfd, F_SETFL, O_NONBLOCK);`
    - тепеь вы можете эффективно опрашивать сокет
    - если попытаетесь читать из неблокируемого сокета, а данных нет, сокет вернёт -1 и установит errno в EWOULDBLOCK
    - но тип опроса плохая идея, если запустите программу в постоянном цикле опроса данных от сокета, она будет тратить процессорное время
    - лучше узнавать, есть ли данные на чтение, другим способоам - см. раздел select()
* посмотреть таблицу маршрутизации:
  + задайте команду `route` `/sbin` или команду `netstat -r`
* выполнять утилиту `ping`, знать что такое ICMP, найти сведения по сырым сокетам и SOCK_RAW
  + W. Richard Stevens' UNIX Network Programming
  + в подоглавлении ping/, http://www.unpbook.com/src.html	
* переключить Ethernet интерфейс в беспорядочный режим, написать анализатор пакетов
  + сетевая карта в “беспорядочном режиме” пропускает в ОС все пакеты, а не только адресованные этой конкретной машине (мы говорим не об IP адресах, а об адресах Ethernet-уровня, и, поскольку уровень Ethernet ниже, чем IP, все IP адреса передаются, см. раздел Низкоуровневый Вздор и Теория сетей.)
  + анализатор пакетов переключает интерфейс в беспорядочный режим => ОС получает все ходящие по проводам пакеты
  + нужно иметь сокет некоторого типа, через который можете читать эти данные
  + действия зависят от платформы


  + Google “windows promiscuous ioctl”
  + http://interactive.linuxjournal.com/article/4659	
* я не прочитала страницы 38 до 63, скорее всего они не понадобятся
